# .NETの非同期処理 第1回

by あれくま

---

# .NETの非同期処理

.NET Frameworkとか.NET Coreとかの非同期処理の話をします。

基本的にC#で話をしますが他の言語でもだいたい同じです。

---

# 非同期処理とは

なんかの処理を裏で勝手にやっといてもらうやつ。

似たようなのに並列処理・並行処理とかあります。

厳密にはよくわからんが、

並列処理(Parallel)
: (ほぼ)同じ処理を複数のデータに対して分散して実行して高速化する。

並行処理(Concurrent)
: 別な処理を同時に実行する。

非同期処理(Asynchronous)
: 並行処理とだいたい同じだが、より非対称性が強いイメージ。
  CPU外に処理をぶん投げて戻ってくるまでCPUは待たずに他の処理をする。

---

# .NETの非同期処理

非同期処理にはいろいろ実現方法がありますが、.NETでは主に次のようなのが使われます。

* Process
* Thread
* ThreadPool
* Task

----

# Process

プロセスは一番基本の処理単位です。

新しくプログラムを起動するとOSがプロセスを作り走らせます。
複数のプロセスは複数のCPUで同時に動かすことができます。

## 利点

* 簡単。わかりやすい。
* (OSにもよるが)何か間違っても他のプロセスへの影響が少ない。

## 欠点

* 起動は遅い。
* 結構メモリを食う。
* プロセス間ののやりとりにはなんらかの通信が必要でめんどい。

ここで言う起動が遅い、メモリを食うというのは、プログラム中で気軽に起動するにはという意味で、
手動実行では瞬時に起動してメモリをほとんど食わないプロセスでも、多量に起動するには遅くてメモリを食うということがあります。

----

# Process の使い方

なんか処理をするプログラムを起動して、結果をなんとかして受け取ります。

``` cs
var proc = Process.Start("ffmpeg ～");
while (!proc.HasExited) {
  Console.WriteLine("処理中。ちょっと待ってね");
}
if (proc.ExitCode==0) {
  Console.WriteLine("完了しました！");
}
else {
  Console.WriteLine("なんか失敗しました！");
}
```

終了コードくらいなら簡単に取れるんですが、整数値一つだけしか受け取れませんし途中経過なんかも取れません。
それ以上のデータはファイルや標準入出力、通信などを使ってやりとりする必要があって結構大変になります。

---

# Thread

スレッドはプロセス内軽量プロセスみたいなものです。

複数のスレッドは複数のCPUで同時に動かすことができます。
アドレス空間を新しく作ったりはせず、一つのプロセス内のスレッドは同じメモリ空間に同時にアクセスすることができます。

## 利点

* プロセスよりも起動が速い。
* 他のスレッドとのやりとりが簡単。

## 欠点

* 起動はまだ遅い。
* プロセス程ではないがやっぱりいくらかメモリを食う。
* 一箇所のメモリに同時アクセスできるのでタイミングの問題によるバグが発生しがち。

起動はプロセスよりは速いのですが、ほんのちょっとした処理を任せたい時には処理時間に対して起動時間の割合が大きくなりがちです。

メモリも沢山起動するにはちょっと大きく、普通は1つのスレッドで数MBのメモリを消費するので100個とか作るとそれだけで数百MBのメモリになってしまいます。

----

# Thread の使い方

裏で勝手に動くスレッドを開始しといて、なんとかして結果を受け取ります。

``` cs
//結果を受け取るリスト
var results = List<string>.new();
//こいつがtrueになったら終了してほしい
var quit = false;
//実行するスレッド
var thread = Thread.new(() => {
  while (!quit) {
    //quitがtrueになるまでなんか処理して
    //結果をリストに入れる
    results.Add(なんか処理());
  }
});
thread.Start(); //実行開始！

//裏で処理されている間、改行が入力されるまで待つ
Console.WriteLine("改行で終了");
Console.ReadLine();

//スレッドの終了要求をして待つ
quit = true;
thread.Join();

//結果を表示する
foreach (var result in results) {
  Console.WriteLine(result);
}
```

この例では実行元(メインスレッド)と裏で実行してるスレッドで同じ変数に対し読み書きしています。
スレッド間は同じメモリ(アドレス空間)を共有しているので、同じ変数に対しての読み書きが可能です。

簡単にいろんなデータを共有できるのはいいのですが、共有された変数がいまここで変更されたらどうなるか？というのを常に意識しないといけないので難しくなります。

たとえば上の例でスレッドの終了待ちのタイミングを結果表示の後にしたらどうなるでしょう？
結果表示をしている間にリストに結果が追加されますが、結果がまだあるかどうかの判定タイミングと結果が追加されるタイミングにより、最後の結果が表示されるかどうかが微妙に変わってきてしまいます[^1]。

[^1]: まあ実際に実行したら列挙中に結果が追加されると例外が出るんですけど。

---

# プロセスやスレッドの切り替え

プロセスやスレッドは、複数のCPUで同時に動かせますが、CPUの数以上のプロセスやスレッドを起動することもできます。

その場合は何が起きるかというと、実行中のプロセス/スレッドを適当なタイミングで中断し、他のプロセス/スレッドに実行を移します。
中断されたプロセス/スレッドは次の番が回ってくるまで待っています。

この切り替え処理はそんなに大きくはないものの時間はかかるので、できることなら減らしたい処理です。
プロセス/スレッドが多くなりすぎると、切り替え処理ばっかりやっててやりたい処理が動かなくなってしまいます。

---

# ThreadPool

スレッドプールは、スレッドを上手く活用する方法です。
* プール=使ってないものを溜めとくところ

あらかじめいくつか作っておいた暇なスレッドに処理を割り当てます。
スレッドは処理が終わったら暇な状態に戻ります。
作っておいたスレッド数以上に処理があった場合は、処理待ちリストに入れといて、スレッドが暇になり次第割り当てます。

## 利点

* スレッドの起動回数が減らせる。
* スレッド数が制御しやすい。
* スレッドの切り替えも減らせる。

スレッドは既に作ってあるものを使うので起動の時間が減らせます。
ほんのちょっとで終わる処理も実行し

スレッド数はスレッドプールが勝手に管理してくれるのであまり気にしなくて良くて便利です。
大抵は使えるCPUコア数に応じて初期値を決めてくれます。

スレッド数が処理の数だけ増えたりしないので、切り替えだけでいっぱいになったりはしません。
空いたスレッドも溜まってる処理があればそのまま実行を始めるので切り替えも減らせます。

## 欠点

* スレッドを長時間占有されると処理が詰まる。
* スレッド間でのやりとり方法については何も解決していない。

いくつかのスレッドを使い回すので、長時間かかる処理をスレッドプール上で実行すると、他の処理で使えるスレッドが減ってしまいます。
重い計算処理とかならどっちにしろCPUいっぱいになるんでかまわないんですが、例えば通信待ちのようなほぼ待ってるだけの処理を行うには向いてません。

----

# ThreadPool の使い方

スレッドは勝手に開始してくれるので、処理だけを指定します。

``` cs

//結果を受け取るリスト
var results = new List<string>();
//処理完了通知を受け取るイベント
var completedEvent = new CountDownEvent(1000);

//1000個程計算する処理を
for (int i=0; i<1000; i++) {
  //スレッドプールで開始
  ThreadPool.QueueUserWorkItem(state => {
      //なんか計算する
      var result = なんか処理((int)state);
      //結果をリストに追加したいが……
      //リストは複数のスレッドから追加される可能性があるのでロックする
      lock (results) {
        //この中は同時に一つのスレッドしか実行されない
        //一つが実行中は他のスレッドは待ってる
        results.Add(result);
      }
      //この処理が終わったのを通知する
      completedEvent.Add();
    }
  }, i);
}

//1000個処理が終わるまで待つ
while (!completedEvent.IsSet) {
  Console.WriteLine("処理中。ちょっと待ってね");
}

//結果を表示する
foreach (var result in results) {
  Console.WriteLine(result);
}

```

スレッドの例と似ていますが、せっかくなので1000個の処理を同時に開始しています。典型的な並列処理の例ですね。
スレッドを1000個一度に立ち上げたらたぶんめちゃくちゃ重くなってなかなか処理が進まないのですが、スレッドプールなら問題なく動いてくれます。

スレッドと違って標準では終わったのを待つ方法はないので、自前で終了待ちするための方法を用意する必要があります。ここでは`CountDownEvent`を使っています。

中身は結局のところスレッドなので変数の共有もできますが、変更されるタイミングに気を配らないといけないもの同じです。

---

# Task
TaskはTask Parallel Library (TPL)というライブラリから導入されたもので、元はその名の通り並列処理のために作られたものです。
ただ、現在は非同期処理にも使われます(というかそっちの方が多い)。

Task自体は非同期でやっていた処理の結果を待って取得するだけのもので、非同期処理を行う仕組みではありません。
処理自体はThreadPoolなどで実行されます。
スレッドプールをもう少し使いやすくするための仕組みと言って良いでしょう。

Taskは主に既に実行が開始された非同期処理を待つためのオブジェクトです。
未実行のTaskを取っておいてあとで開始するというのはやりません。
できなくはないですがやらない方がいいでしょう。

基本的にはJavaScriptのPromiseやC++のfutureと同じです。

## 利点

* 処理間のやりとりが簡単になる。
  * 終わった処理結果を受け取るだけなのでメモリ読み書きのタイミング問題が発生しない。
* 継続が渡せる。

Taskは処理結果を返せる機能があるので、結果をどこかに保存しないと…という心配をする必要がありません。
終わったTaskの処理結果だけが取得できるので、同時に読み書きが行われる心配もしなくて大丈夫です。
また、Taskの処理が終わってるかどうかも取得できるので、別途終了待ちをする方法を用意しなくてかまいません。

継続は、その処理が終わった後でこの処理もやってくれ、と追加の処理を指定する機能です。
確実にこの非同期処理が終わったあとに実行はされるが、そのまま非同期でついでにやっておいて欲しい処理を簡単に追加できます。

## 欠点

* 実際どこで実行されるかはわかりづらい。
* 継続を連鎖させるのはめんどくさい。

Taskは非同期処理の結果を待つためのオブジェクトであり、その非同期処理がどこで実行されてるかは問いません。
スレッドプールで実行されてることは多いのですが、そうとも限りません。
たいていの場合はどのスレッドで実行されててもかまわないのですが、うっかり長時間かかる処理を継続などに渡すと思わぬスレッドが固まって動かなくなったりします。

継続は`ContinueWith()`というメソッドで追加できるのですが、継続のあとに実行される継続のあとに実行される...と連鎖していくととても見づらいプログラムが完成します。
まあ真っ直ぐ進むならまだマシなんですが、エラー処理とかが含まれると死ぬ程大変なことになります。

----

# Task の使い方

``` cs
var tasks = new List<Task<string>>();
//1000個程計算する処理を
for (int i=0; i<1000; i++) {
  //スレッドプールで開始
  var task = Task.Run(() => {
      //なんか計算して結果を返す
      return なんか処理(i);
  });
  //処理中のタスクとして取っておく
  tasks.Add(task);
}

//全部のタスクが終わったら終わるタスクを作る
var allTask = Task.WhenAll(tasks);

//全部処理が終わるまで待つ
while (!allTask.IsCompleted) {
  Console.WriteLine("処理中。ちょっと待ってね");
}

//結果を表示する
//allTask.Result には各タスクの処理が返した結果が配列で入ってるぞ
foreach (var result in allTask.Result) {
  Console.WriteLine(result);
}
```

やってる処理はスレッドプールとだいたい同じですが、すっきりしました。

終わりを待つのは`IsCompleted`プロパティの監視や`Wait()`メソッドで出来ますし、結果もどこか変数に入れずに `return` したやつを `Result` プロパティで取得できます。
さすが並列処理向けのライブラリだけあってこういった並列処理はとても簡単に実現できますね。

---

# おしまい

準備がさっぱり間に合わなかったので今回はここまで。

まだ全然闇に踏み込んでないんですけど、今後何回かに分けてどんどんつらい話をしていきたいと思います。


